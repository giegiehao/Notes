# 数据结构

1. 栈

2. 队列

3. 链表

4. 数组

5. 哈希表

6. 树 
   - 哈夫曼树 (Huffman)
   - 二叉排序树（BST)
   - 平衡二叉树 (AVL)

7. 图

8. 堆



### 模拟

​	顾名思义，模拟是通过发编程来模拟某一过程或情景，以解决具体的问题。通过模拟实际情况来解决问题，一般容易理解但是实现起来比较复杂，有很多需要注意的细节，考察细心程度和整体的逻辑思维。
​	一般为了使模拟题写的逻辑清晰一些，经常会写比较多的小函数来帮助解题，比如int和string的相互转换、回文串的判断、日期的转换、各种特殊条件的判断等。

常见题型

- 字符串处理：如回文字符串检查、字符串的各种变换和操作
- 数字问题模拟：如大数运算、复杂的数字公式或定理的编程实现
- 日常生活模拟：比如模拟商店营业过程、交通流量分析等



# 算法



算法的时间复杂度？

时间频度：一个算法花费的时间与算法中语句的执行次数成正比，一个算法中的语句执行次数被称为语句频度或时间频度。记为T(n)



高精度：

- 高精度加法
- 高精度减法
- 高精度乘法
- 高精度除以低精度
- 高精度除以高精度



排序算法：

冒泡排序

选择排序

插入排序

希尔排序

快速排序

基数排序（桶排序）

堆排序





查找算法：

线性查找： 最简单的查找，一条线遍历数据，找到就返回

二分查找 ：递归写法、非递归写法

插值查找：在二分公式中插入目标值进行定位中点，根据目标值在数组中的比例位置进行定位，比二分查找可能更快的找到目标值

斐波那契查找： 与二分查找类似，不同在于中轴和左右两部分按照斐波那契数组来划分 感觉不如直接用二分，代码复杂太多辽

![image-20231110002546192](C:\Users\ouxiaoxin\AppData\Roaming\Typora\typora-user-images\image-20231110002546192.png)

分块查找





分治算法：分而治之

​	分治算法的三分步骤：

- 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
- 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
- 合并：将各个子问题的解合并为原问题的解

应用例子：汉诺塔问题



贪心算法



最小生成树：（未学）

![image-20231124111017204](C:\Users\ouxiaoxin\AppData\Roaming\Typora\typora-user-images\image-20231124111017204.png)

普利姆算法prim

克鲁斯卡尔算法





动态规划：核心思想：将大问题划分为若干个小问题进行解决，经分析得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上进行求解） 动态规划可以使用填表的方式进行求解

动态规划最核心的思想，就在于**拆分子问题，记住过往，减少重复计算**

- 穷举分析
- 确定边界
- 找出规律，确定最优子结构
- 写出状态转移方程

暴力dfs  --> 记忆化搜索 --> 递推(dp)

记忆化搜索 = 暴力dfs + 记录过程

递推的公式 = dfs向下递归的公式

递推数组的初始值 = 递归的边界





KMP字符匹配算法



赫夫曼树：wpl最小的就是赫夫曼树

- 赫夫曼算法采用的是**贪心策略**，贪心策略不是对所有问题都能得到最优解，但**赫夫曼算法得到的是最优解**
- n个叶子结点的赫夫曼树共有**2n-1**个结点
- 赫夫曼树中不会有度为1的结点



赫夫曼数应用：赫夫曼编码

赫夫曼编码： 

1. 统计每个字符出现的权值
2. 通过权值创建一颗赫夫曼树
3. 通过赫夫曼树的路径（左0右1）构造赫夫曼编码表key：byte，value：String
4. 遍历原来的字节数据，通过编码表获得一串二进制字符串，二进制字符串每八位（原码）转化为十进制，构成一个字节（补码）组成字节数组，这个数组就是压缩后的数据

解码过程

1. 压缩后的数据是字节数组，对每个字节转换为二进制，获得一串长二进制字符串





二叉排序树：左节点的值比当前值小，右节点的值比当前值大



平衡二叉树





## 数论

### 算术基本定理：每个整数都是由若干个质因数组成



### 欧拉函数

欧拉函数（Euler's totient function）表示的是小于等于 n和 n互质的数的个数。

![image-20240408101215131](F:\Notes\image-20240408101215131.png)

例：1323
1323 = 3^3*7^2;
通过欧拉函数求小于等于n和n互质的数的个数：
3^(3-1) * (3-1) * 7^(2-1) * (7-1) = 6 * 2 * 7 * 6





## 前缀和



## 差分



## 分块

