# 23种设计模式（java） -浅入待深入

[黑马程序员 23种设计模式](https://www.bilibili.com/video/BV1Np4y1z7BU/?spm_id_from=333.337.search-card.all.click)



## 软件设计原则

- 单一职责原则：设计目的单一的类
- 开闭原则：对扩展开放，对修改关闭
- 里氏代换原则：子类可以替代父类
- 依赖倒转原则：抵赖抽象而不依赖具体实现类
- 接口隔离原则：使用多个接口比使用一个复杂的接口好
- 迪米特原则（最小知识原则）：两个无需直接通信的对象，就不应该存在直接调用关系
- 组成复合原则：尽量使用组合或聚合关系，其次再考虑继承



## 一、创建型模式

关注“怎样创建对象？”，特点是“将对象的创建和使用分离”

### 1. 单例模式（Singleton Pattern)

保证一个类只有单个对象，并提供全局访问

#### 饿汉式：类加载就会导致该单例对象被创建

```java
1.静态变量，提供静态的公共访问方法
    
    
2.静态代码块中对单例对象进行赋值
```



#### 懒汉式：类加载不会导致单例对象被创建，而是在首次需要使用该对象时才被创建

```java
1.（线程不安全)调用访问方法时判断单例对象是否为空，如果不为空则创建，再返回该单例对象
     
    
//线程安全
2.在公共访问方法上加上synchronized关键字，加锁（慢）
    
3.双重检查锁：(快)
    if (singletonObject == null) {
        synchronized(xx.class) {
            if (singletonObject == null) {
                singletonObject = new SingletonClass();
            }
        }
    }

4.静态内部类：静态内部类只会在使用时被jvm创建一次，则该类中的对象也被创建一次
    
5.枚举方式
```



#### 单例模式破环





### 2. 工厂方法模式（Factory Method)

定义一个用于创建对象的接口（抽象工厂），让子类决定实例化哪个产品类对象。工厂方式使得产品类实例化延迟到其工厂的子类。**一个抽象工厂生产同等级产品（同类），具体产品由具体工厂决定**

```java
1.抽象工厂(Abstract Factory)：提供了创建产品的接口，调用者通过它访问集体工厂的工厂方法来创建产品
2.具体工厂(Concrete Factory)
3.抽象产品(Product)
4.具体产品(Concrete Product)
//抽象工厂定义了具体工厂的生产线（抽象产品），具体产品由具体工厂来决定
```

> 优点：
> ·用户只需要知道具体工厂的名称就可得到所要的产品，**无须知道产品的具体创建过程**；
> ·在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
>
> 缺点：
> ·每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。





### 3. 抽象工厂模式（Abstract Factory)

与工厂方法不同的是，抽象工厂模式**抽象工厂可以生产同族（品牌）产品，具体某个产品组由具体工厂决定**

```java
1.抽象工厂：提供了创建产品的接口，包含多个创建产品的方法，可以创建多个不同等级的产品
2.具体工厂
3.抽象产品
4.具体产品
```



### 4. 原型模式(Prototype)

用一个已经创建的实例作为原型，通过**克隆**该原型对象来创建一个和原型对象相同的新对象

```java
//浅克隆
1.抽象原型类：clone()方法，java中自带Cloneable接口
2.具体原型类：实现clone方法，表示该对象可复制
3.访问类：使用具体原型类的clone方法，复制一个新对象
//深克隆
使用序列化和反序列化
```

> 浅克隆：创建一个新对象，新对象的属性和原来完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址
>
> 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址



### 5. 建造者模式（Builder）

将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示

- 分离了**部件的构造（由Builder来负责）**和**装配（由Director负责）**。从而可以构造出复杂的对象，这个模式适用于：某个对象的构建过程复杂的情况。
- 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顶序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
- 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

```java
1.抽象建造者类(Builder)：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建具体
    
2.建造者类(ConcreteBuilder):实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。
    
3.产品类(Product):要创建的复杂对象。
    
4.指挥者类(Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。
```

指挥者类Director在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，*有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合，但是不太符合单一职责原则*

>优点：
>·建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
>·在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
>·可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
>·建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。
>
>缺点：
>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
>
>使用场景
>建造者(Builder)模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。
>·创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
>·创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。

#### 建造者模式扩展

建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。



## 二、结构型模式

“如何将类或对象按某种布局组成更大的结构”。分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。

### 6.代理模式（Proxy）

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。

```java
·抽象主题(Subject)类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    
·真实主题(Rea1 Subject)类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。

·代理(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
```





### 7.适配器模式（Adapter）

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

```java
·目标(Target)接口：当前系统业务所期待的接口，它可以是抽象类或接口。
    
·适配者(Adaptee)类：它是被访问和适配的现存组件库中的组件接口。
    
·适配器(Adapter)类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。适配者——>目标接口
```

>使用场景：
>
>- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
>- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

#### 类适配器模式

实现方法：*定义一个适配器类来实现当前系统的业务接口（目标接口），且同时**继承**现有组件库中已经存在的组件（适配者类）*，在实现的接口方法中调用适配器的方法，达到适配、中转的效果。

>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用（无法多继承）。

#### 对象适配器模式

实现方法：*将现有组件库（适配器）中已经实现的组件**引入**到适配器类中，同时实现当前系统的业务接口*（目标接口）。

#### 接口适配器模式

当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，实现所有方法。而此时我们只需要继承该抽象类即可。





### 8.装饰者模式（Decorator）

在不改变现有对象结构的情况下，动态地给该对象增加一些职责（额外功能）的模式

```java
1.抽象构件（Component）：定义一个抽象接口一规范准备接收附加责任的对象
    
2.具体构件(Concrete Component)：实现抽象构件，通过装饰角色为其添加一些职责。
    
3.抽象装饰(Decorator)：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能//继承并聚合抽象构建

4.具体装饰(ConcreteDecorator)：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
    
```

![image-20240507104928732](F:\Notes\23种设计模式\image-20240507104928732.png)

>
>
>*好处：*
>·装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任：
>
>·装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
>
>使用场景：
>·当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：
>
>- 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；
>
>- 第二类是因为类定义不能继承（如final类）
>
>·在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
>
>·当对象的功能要求可以动态地添加，也可以再动态地撤销时。



>*静态代理和装饰者的区别*
>
>·相同点：
>
>- 都要实现与目标类相同的业务接口
>
>- 在两个类中都要声明目标对象
>
>- 都可以在不修改目标类的前提下增强目标方法
>
>·不同点：
>
>  - 目的不同
>    装饰者是为了增强目标对象
>    静态代理是为了保护和隐藏目标对象
>  - 获取目标对象构建的地方不同
>    装饰者是由外界传递进来，可以通过构造方法传递
>    静态代理是在代理类内部创建，以此来隐藏目标对象
>
>



### 9.桥接模式（Bridge）

将抽象与实现分离，使他们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

```java
1.抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用

2.扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类的业务方法，并通过组合关系调用实现化角色中的业务方法

3.实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色使用
   
4.具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现
```

![屏幕截图 2024-05-07 225717](F:\Notes\23种设计模式\屏幕截图 2024-05-07 225717-17150938568161.png)

>*好处：*
>·桥接模式提高了系统的可扩充性，*在两个变化维度中任意扩展一个维度，都不需要修改原有系统*。如：如果现在还有一种视频文件类型wmy,我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。
>
>·实现细节对客户透明
>
>*使用场景*
>·当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
>
>·当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
>
>·当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式
>可以使它们在抽象层建立一个关联关系。

 

### 10.外观模式（Facade）

又名门面模式，是一种通过**为多个复杂的子系统提供一个一致的接口**，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
外观(Facade)模式是"迪米特法则"的典型应用

```java
1.外观（Facade）角色：为多个子系统对外提供一个共同的接口。

2.子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
```

![image-20240507235200124](F:\Notes\23种设计模式\image-20240507235200124.png)

>*好处：*
>·降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
>
>·对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
>
>*缺点：*
>·不符合开闭原则，修改很麻烦
>
>*使用场景*
>·对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
>
>·当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
>
>·当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。



### 11.组合模式（Composite）

又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

例如文件系统，文件夹中有文件（叶子对象）和文件夹（容器对象），但是希望能够一致的对待容器对象和叶子对象。

```java
·抽象根节点(Component)：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。
    
·树枝节点(Composite):定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。
    
·叶子节点（Leaf)：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。
```

#### 透明组合模式：

抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中MenuComponent声明了add、remove、getchild方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的**标准形式**。

透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）

![image-20240508184845234](F:\Notes\23种设计模式\image-20240508184845234.png)

#### *还有一种安全组合模式：*

在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点`Menu`类中声明并实现这些方法。安全组合模式的**缺点是不够透明**，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。



>*优点：*
>·组合模式可以清楚地定义**分层次的复杂对象**，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
>
>·客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
>
>·在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
>
>·组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。
>
>*使用场景：*
>组合模式正是应**树形结构**而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。





### 12.享元模式（Flyweight）

运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。

享元模式中存在以下两种状态：

1. 内部状态，即不会随着环境的改变而改变的可共享部分。
2. 外部状态，指随环境改变而改孪的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。

```java
·抽象享元角色(F1 yweight)：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
    
·具体享元(Concrete Flyweight)角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
    
·非享元(Unsharable Flyweight)角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
    
·享元工厂(Flyweight Factory)角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。
```

![image-20240508194509275](F:\Notes\23种设计模式\image-20240508194509275.png)

>*优点：*
>·极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能
>
>·享元模式中的外部状态相对独立，且不影响内部状态
>
>*缺点：*
>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂
>
>*使用场景：*
>·一个系统有大量相同或者相似的对象，造成内存的大量耗费。
>
>·对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
>
>·在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。
>
>





## 三、行为型模式

涉及**算法与对象间职责的分配**。不仅描述类或对象间的相互协作的模式，还描述它们之间的通信模式。

行为型模式分为采用继承机制的类行为模式，和采用组合或聚合的对象行为模式，对象行为模式耦合低，更具有灵活性。*行为型模式大多使用对象行为模式，使用继承机制的类行为模式有模板方法（Template Method）和解释器（Interpreter）两种。*

### 13.模板方法（Template Method）

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

```java
·抽象类(Abstract Class):负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。
   - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
   - 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：
	1.抽象方法(Abstract Method):一个抽象方法由抽象类声明、由其具体子类实现。
	2.具体方法(Concrete Method)：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。
	3.钩子方法(Hook Method)：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXXX，返回值类型为boolean类型。
    
·具体子类(Concrete Class)：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。
```

![image-20240508204803930](F:\Notes\23种设计模式\image-20240508204803930.png)

>*优点：*
>·提高代码复用性
>		将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。
>
>·实现了反向控制
>		通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”。
>
>*缺点：*
>·对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
>
>·父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
>
>*适用场景*
>·算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
>
>·需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。
>
>



### 14.策略模式（Strategy）

该模式定义了一系列算法，并将每个算法封装起来，使它们可以**相互替换**，且算法的变化不会影响使用算法的客户。策略模式属于对象行为，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来。

把不同的行为（算法）封装到不同的类里，供需要完成这个行为的对象进行**选择**。

```java
·抽象策略(Strategy)类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
    
·具体策略(Concrete Strategy)类：实现了抽象策略定义的接口，提供具体的算法实现或行为。
    
·环境(Context)类：持有一个策略类的引用，最终给客户端调用。
```

![image-20240508232411527](F:\Notes\23种设计模式\image-20240508232411527.png)



>*优点：*
>·策略类之间可以自由切换
>		由于策略类都实现同一个接口，所以使它们之间可以自由切		换。
>
>·易于扩展
>		增加一个新的策略只需要添加一个具体的策略类即可，基本		不需要改变原有的代码，符合“开闭原则”。
>
>·避免使用多重条件选择语句（if else），充分体现面向对象设计思想。
>
>*缺点：*
>·客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
>
>·策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
>
>*使用场景：*
>·一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。
>
>·一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。
>
>·系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。
>
>



### 15.命令模式（Command）

将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。支持**可撤销**操作。

```java
·抽象命令类(Command)角色：定义命令的接口，声明执行的方法。
    
·具体命令(Concrete Command)角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
    
·实现者/接收者(Receiver)角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
    
·调用者/请求者(Invoker)角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
```

![image-20240509001919431](F:\Notes\23种设计模式\image-20240509001919431.png)

![image-20240509001940439](F:\Notes\23种设计模式\image-20240509001940439.png)



>*优点：*
>·降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
>
>·增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
>
>·可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
>
>·方便实现Undo和Redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。
>
>*缺点：*
>·使用命令模式可能会导致某些系统有过多的具体命令类。
>
>·系统结构更加复杂。
>
>*使用场景：*
>·系统需要将请求**调用者和请求接收者解耦**，使得调用者和接收者不直接交互。
>
>·系统需要在不同的时间指定请求、将请求排队和执行请求。
>
>·系统需要支持命令的**撤销(Undo)操作和恢复(Redo)操作**。
>
>





### 16.责任链模式（Chain of Responsibility)





































