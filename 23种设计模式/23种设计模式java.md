# 23种设计模式（java） -浅入待深入

[黑马程序员 23种设计模式](https://www.bilibili.com/video/BV1Np4y1z7BU/?spm_id_from=333.337.search-card.all.click)



## 软件设计原则

- 单一职责原则：设计目的单一的类
- 开闭原则：对扩展开放，对修改关闭
- 里氏代换原则：子类可以替代父类
- 依赖倒转原则：抵赖抽象而不依赖具体实现类
- 接口隔离原则：使用多个接口比使用一个复杂的接口好
- 迪米特原则（最小知识原则）：两个无需直接通信的对象，就不应该存在直接调用关系
- 组成复合原则：尽量使用组合或聚合关系，其次再考虑继承



## 一、创建型模式

关注“怎样创建对象？”，特点是“将对象的创建和使用分离”

### 1. 单例模式（Singleton Pattern)

保证一个类只有单个对象，并提供全局访问

#### 饿汉式：类加载就会导致该单例对象被创建

```java
1.静态变量，提供静态的公共访问方法
    
    
2.静态代码块中对单例对象进行赋值
```



#### 懒汉式：类加载不会导致单例对象被创建，而是在首次需要使用该对象时才被创建

```java
1.（线程不安全)调用访问方法时判断单例对象是否为空，如果不为空则创建，再返回该单例对象
     
    
//线程安全
2.在公共访问方法上加上synchronized关键字，加锁（慢）
    
3.双重检查锁：(快)
    if (singletonObject == null) {
        synchronized(xx.class) {
            if (singletonObject == null) {
                singletonObject = new SingletonClass();
            }
        }
    }

4.静态内部类：静态内部类只会在使用时被jvm创建一次，则该类中的对象也被创建一次
    
5.枚举方式
```



#### 单例模式破环





### 2. 工厂方法模式（Factory Method)

定义一个用于创建对象的接口（抽象工厂），让子类决定实例化哪个产品类对象。工厂方式使得产品类实例化延迟到其工厂的子类。**一个抽象工厂生产同等级产品（同类），具体产品由具体工厂决定**

```java
1.抽象工厂(Abstract Factory)：提供了创建产品的接口，调用者通过它访问集体工厂的工厂方法来创建产品
2.具体工厂(Concrete Factory)
3.抽象产品(Product)
4.具体产品(Concrete Product)
//抽象工厂定义了具体工厂的生产线（抽象产品），具体产品由具体工厂来决定
```

> 优点：
> ·用户只需要知道具体工厂的名称就可得到所要的产品，**无须知道产品的具体创建过程**；
> ·在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；
>
> 缺点：
> ·每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。





### 3. 抽象工厂模式（Abstract Factory)

与工厂方法不同的是，抽象工厂模式**抽象工厂可以生产同族（品牌）产品，具体某个产品组由具体工厂决定**

```java
1.抽象工厂：提供了创建产品的接口，包含多个创建产品的方法，可以创建多个不同等级的产品
2.具体工厂
3.抽象产品
4.具体产品
```



### 4. 原型模式(Prototype)

用一个已经创建的实例作为原型，通过**克隆**该原型对象来创建一个和原型对象相同的新对象

```java
//浅克隆
1.抽象原型类：clone()方法，java中自带Cloneable接口
2.具体原型类：实现clone方法，表示该对象可复制
3.访问类：使用具体原型类的clone方法，复制一个新对象
//深克隆
使用序列化和反序列化
```

> 浅克隆：创建一个新对象，新对象的属性和原来完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址
>
> 深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址



### 5. 建造者模式（Builder）

将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示

- 分离了**部件的构造（由Builder来负责）**和**装配（由Director负责）**。从而可以构造出复杂的对象，这个模式适用于：某个对象的构建过程复杂的情况。
- 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顶序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
- 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

```java
1.抽象建造者类(Builder)：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建具体
    
2.建造者类(ConcreteBuilder):实现Builder接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。
    
3.产品类(Product):要创建的复杂对象。
    
4.指挥者类(Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。
```

指挥者类Director在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，*有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合，但是不太符合单一职责原则*

>优点：
>·建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
>·在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
>·可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
>·建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。
>
>缺点：
>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
>
>使用场景
>建造者(Builder)模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。
>·创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
>·创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。

#### 建造者模式扩展

建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。



## 二、结构型模式

“如何将类或对象按某种布局组成更大的结构”。分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。

### 6.代理模式（Proxy）

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。

```java
·抽象主题(Subject)类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    
·真实主题(Rea1 Subject)类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。

·代理(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
```





### 7.适配器模式（Adapter）

将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

```java
·目标(Target)接口：当前系统业务所期待的接口，它可以是抽象类或接口。
    
·适配者(Adaptee)类：它是被访问和适配的现存组件库中的组件接口。
    
·适配器(Adapter)类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。适配者——>目标接口
```

>使用场景：
>
>- 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
>- 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。

#### 类适配器模式

实现方法：*定义一个适配器类来实现当前系统的业务接口（目标接口），且同时**继承**现有组件库中已经存在的组件（适配者类）*，在实现的接口方法中调用适配器的方法，达到适配、中转的效果。

>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用（无法多继承）。

#### 对象适配器模式

实现方法：*将现有组件库（适配器）中已经实现的组件**引入**到适配器类中，同时实现当前系统的业务接口*（目标接口）。

#### 接口适配器模式

当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter，实现所有方法。而此时我们只需要继承该抽象类即可。





### 8.装饰者模式（Decorator）

在不改变现有对象结构的情况下，动态地给该对象增加一些职责（额外功能）的模式

```java
1.抽象构件（Component）：定义一个抽象接口一规范准备接收附加责任的对象
    
2.具体构件(Concrete Component)：实现抽象构件，通过装饰角色为其添加一些职责。
    
3.抽象装饰(Decorator)：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能//继承并聚合抽象构建

4.具体装饰(ConcreteDecorator)：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
    
```

![image-20240507104928732](F:\Notes\23种设计模式\image-20240507104928732.png)

>
>
>*好处：*
>·装饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任：
>
>·装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
>
>使用场景：
>·当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能采用继承的情况主要有两类：
>
>- 第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；
>
>- 第二类是因为类定义不能继承（如final类）
>
>·在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
>
>·当对象的功能要求可以动态地添加，也可以再动态地撤销时。



>*静态代理和装饰者的区别*
>
>·相同点：
>
>- 都要实现与目标类相同的业务接口
>
>- 在两个类中都要声明目标对象
>
>- 都可以在不修改目标类的前提下增强目标方法
>
>·不同点：
>
>  - 目的不同
>    装饰者是为了增强目标对象
>    静态代理是为了保护和隐藏目标对象
>  - 获取目标对象构建的地方不同
>    装饰者是由外界传递进来，可以通过构造方法传递
>    静态代理是在代理类内部创建，以此来隐藏目标对象
>
>



### 9.桥接模式（Bridge）

将抽象与实现分离，使他们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

```java
1.抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用

2.扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类的业务方法，并通过组合关系调用实现化角色中的业务方法

3.实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色使用
   
4.具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现
```

![屏幕截图 2024-05-07 225717](F:\Notes\23种设计模式\屏幕截图 2024-05-07 225717-17150938568161.png)

>*好处：*
>·桥接模式提高了系统的可扩充性，*在两个变化维度中任意扩展一个维度，都不需要修改原有系统*。如：如果现在还有一种视频文件类型wmy,我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。
>
>·实现细节对客户透明
>
>*使用场景*
>·当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。
>
>·当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。
>
>·当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式
>可以使它们在抽象层建立一个关联关系。

 

### 10.外观模式（Facade）

又名门面模式，是一种通过**为多个复杂的子系统提供一个一致的接口**，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
外观(Facade)模式是"迪米特法则"的典型应用

```java
1.外观（Facade）角色：为多个子系统对外提供一个共同的接口。

2.子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
```

![image-20240507235200124](F:\Notes\23种设计模式\image-20240507235200124.png)

>*好处：*
>·降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
>
>·对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
>
>*缺点：*
>·不符合开闭原则，修改很麻烦
>
>*使用场景*
>·对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。
>
>·当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。
>
>·当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。



### 11.组合模式（Composite）

又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

例如文件系统，文件夹中有文件（叶子对象）和文件夹（容器对象），但是希望能够一致的对待容器对象和叶子对象。

```java
·抽象根节点(Component)：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。
    
·树枝节点(Composite):定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。
    
·叶子节点（Leaf)：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。
```

#### 透明组合模式：

抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中MenuComponent声明了add、remove、getchild方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的**标准形式**。

透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供add()、remove()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）

![image-20240508184845234](F:\Notes\23种设计模式\image-20240508184845234.png)

#### *还有一种安全组合模式：*

在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点`Menu`类中声明并实现这些方法。安全组合模式的**缺点是不够透明**，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。



>*优点：*
>·组合模式可以清楚地定义**分层次的复杂对象**，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
>
>·客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
>
>·在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
>
>·组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。
>
>*使用场景：*
>组合模式正是应**树形结构**而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。





### 12.享元模式（Flyweight）

运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。

享元模式中存在以下两种状态：

1. 内部状态，即不会随着环境的改变而改变的可共享部分。
2. 外部状态，指随环境改变而改孪的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。

```java
·抽象享元角色(Flyweight)：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。
    
·具体享元(Concrete Flyweight)角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。
    
·非享元(Unsharable Flyweight)角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。
    
·享元工厂(Flyweight Factory)角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。
```

![image-20240508194509275](F:\Notes\23种设计模式\image-20240508194509275.png)

>*优点：*
>·极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能
>
>·享元模式中的外部状态相对独立，且不影响内部状态
>
>*缺点：*
>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂
>
>*使用场景：*
>·一个系统有大量相同或者相似的对象，造成内存的大量耗费。
>
>·对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
>
>·在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。
>
>





## 三、行为型模式

涉及**算法与对象间职责的分配**。不仅描述类或对象间的相互协作的模式，还描述它们之间的通信模式。

行为型模式分为采用继承机制的类行为模式，和采用组合或聚合的对象行为模式，对象行为模式耦合低，更具有灵活性。*行为型模式大多使用对象行为模式，使用继承机制的类行为模式有模板方法（Template Method）和解释器（Interpreter）两种。*

### 13.模板方法（Template Method）

定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。

```java
·抽象类(Abstract Class):负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。
   - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。
   - 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：
	1.抽象方法(Abstract Method):一个抽象方法由抽象类声明、由其具体子类实现。
	2.具体方法(Concrete Method)：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。
	3.钩子方法(Hook Method)：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXXX，返回值类型为boolean类型。
    
·具体子类(Concrete Class)：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。
```

![image-20240508204803930](F:\Notes\23种设计模式\image-20240508204803930.png)

>*优点：*
>·提高代码复用性
>		将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。
>
>·实现了反向控制
>		通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制，并符合“开闭原则”。
>
>*缺点：*
>·对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
>
>·父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
>
>*适用场景*
>·算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。
>
>·需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。
>
>



### 14.策略模式（Strategy）

该模式定义了一系列算法，并将每个算法封装起来，使它们可以**相互替换**，且算法的变化不会影响使用算法的客户。策略模式属于对象行为，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来。

把不同的行为（算法）封装到不同的类里，供需要完成这个行为的对象进行**选择**。

```java
·抽象策略(Strategy)类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
    
·具体策略(Concrete Strategy)类：实现了抽象策略定义的接口，提供具体的算法实现或行为。
    
·环境(Context)类：持有一个策略类的引用，最终给客户端调用。
```

![image-20240508232411527](F:\Notes\23种设计模式\image-20240508232411527.png)



>*优点：*
>·策略类之间可以自由切换
>		由于策略类都实现同一个接口，所以使它们之间可以自由切		换。
>
>·易于扩展
>		增加一个新的策略只需要添加一个具体的策略类即可，基本		不需要改变原有的代码，符合“开闭原则”。
>
>·避免使用多重条件选择语句（if else），充分体现面向对象设计思想。
>
>*缺点：*
>·客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
>
>·策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
>
>*使用场景：*
>·一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。
>
>·一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。
>
>·系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。
>
>



### 15.命令模式（Command）

将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。支持**可撤销**操作。

```java
·抽象命令类(Command)角色：定义命令的接口，声明执行的方法。
    
·具体命令(Concrete Command)角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
    
·实现者/接收者(Receiver)角色：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
    
·调用者/请求者(Invoker)角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
```

![image-20240509001919431](F:\Notes\23种设计模式\image-20240509001919431.png)

![image-20240509001940439](F:\Notes\23种设计模式\image-20240509001940439.png)



>*优点：*
>·降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。
>
>·增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。
>
>·可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
>
>·方便实现Undo和Redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。
>
>*缺点：*
>·使用命令模式可能会导致某些系统有过多的具体命令类。
>
>·系统结构更加复杂。
>
>*使用场景：*
>·系统需要将请求**调用者和请求接收者解耦**，使得调用者和接收者不直接交互。
>
>·系统需要在不同的时间指定请求、将请求排队和执行请求。
>
>·系统需要支持命令的**撤销(Undo)操作和恢复(Redo)操作**。
>
>





### 16.责任链模式（Chain of Responsibility)

又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

```java
·抽象处理者(Handler)角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
    
·具体处理者(Concrete Handler)角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。
    
·客户类(cliet)角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。
```

![image-20240509153637830](F:\Notes\23种设计模式\image-20240509153637830.png)



>**优点**
>·降低了对象之间的耦合度
>		该模式降低了请求发送者和接收者的耦合度。
>
>·增强了系统的可扩展性
>		可以根据需要增加新的请求处理类，满足开闭原侧。
>
>·增强了给对象指派职责的灵活性
>		当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除		责任。
>
>·责任链简化了对象之间的连接
>		一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多		的`if`或者`if else`语句。
>
>·责任分担
>		每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，		符合类的单一职责原侧。
>
>**缺点**
>·不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。
>
>·对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
>
>·职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。



### 17.状态模式（State）

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为

```java
·环境(Context)角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。
    
·抽象状态(State)角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。
    
·具体状态(Concrete State)角色：实现抽象状态所对应的行为。
```

![image-20240509202103297](F:\Notes\23种设计模式\image-20240509202103297.png)

>**优点**
>·将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
>
>·允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。
>
>**缺点**
>·状态模式的使用必然会增加系统类和对象的个数。
>
>·状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
>
>·状态模式对"开闭原则"的支持并不太好。
>
>**使用场景**
>·当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。
>
>·一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。
>
>



### 18.观察者模式（Observer）

又被称为发布-订阅(Publish/Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

```java 
·Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
    
·ConcreteSubiect:具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
    
·Observer:抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
    
·Concrereobserver:具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。
```

![image-20240509211211430](F:\Notes\23种设计模式\image-20240509211211430.png)

对于监听某个状态改变：创建一个唯一改变该状态的方法，在该方法下改变状态，并且通知观察者。

>**优点**
>·降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
>
>·被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】
>
>**缺点**
>·如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时
>
>·如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃
>
>**使用场景**
>·对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。
>
>·当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。
>
>



### 19.中介者模式（Mediator）

又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。

```java
·抽象中介者(Mediator)角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。
    
·具体中介者(ConcreteMed1atQr)角色：实现中介者接口，定义一个List来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。
    
·抽象同事类(colleague)角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
    
·具体同事类(Concrete Colleague)角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。
```

![image-20240510000047969](F:\Notes\23种设计模式\image-20240510000047969.png)

![在这里插入图片描述](F:\Notes\23种设计模式\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkwNTM4Nw==,size_16,color_FFFFFF,t_70.png)

>**优点**
>·松散耦合
>		中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦		合，基本上可以做到巨补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那		样“奉一处而动全身”了。
>
>·集中控制交互
>		多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只		需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事		类不需要做修改。
>
>·一对多关联转变为一对一的关联
>		没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者		对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。
>
>**缺点**
>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。
>
>**使用场景**
>·系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。
>
>·当想创建一个运行于多个类之间的对象，又不想生成新的子类时。
>
>



### 20.迭代器模式（Iterator）

提供一个对象来**顺序访问**聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

```java
·抽象聚合(Aggregate)角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。
    
·具体聚合(ConcreteAggregate)角色：实现抽象聚合类，返回一个具体迭代器的实例。
    
·抽象迭代器(Iterator)角色：定义访问和遍历聚合元素的接口，通常包含hasNext()、next()等方法。
    
·具体迭代器(Concretelterator)角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。
```

![image-20240510003636189](F:\Notes\23种设计模式\image-20240510003636189.png)

>java中想要使用迭代器模式，只要让自定义容器类实现`Iterable`接口，并实现`iterator()`方法使其返回一个`Iterator`的实现类即可

>
>
>**优点**
>·它支持以不同的方式**遍历**一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。
>
>·迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。
>
>·在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。
>
>**缺点**
>增加了类的个数，这在一定程度上增加了系统的复杂性。
>
>**使用场景**
>·当需要为聚合对象提供多种遍历方式时。
>
>·当需要为遍历不同的聚合结构提供一个统一的接口时。
>
>·当访问一个聚合对象的内容而无须暴露其内部细节的表示时。



21.### 访问者模式（Visitor）



























































